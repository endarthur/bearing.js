<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>bearing.js — Statistics &amp; Contouring Demo</title>
  <style>
    body {
      font-family: system-ui, sans-serif;
      max-width: 1000px;
      margin: 2rem auto;
      padding: 0 1rem;
      color: #333;
    }
    h1 { margin-bottom: 0.25rem; }
    h2 { margin-top: 2rem; }
    .row {
      display: flex;
      gap: 2rem;
      flex-wrap: wrap;
      align-items: flex-start;
      margin-bottom: 1.5rem;
    }
    .plot { text-align: center; }
    .plot h3 { margin: 0.5rem 0; }
    .stats {
      font-size: 0.85rem;
      line-height: 1.6;
      background: #f8f8f8;
      border: 1px solid #ddd;
      border-radius: 6px;
      padding: 1rem 1.2rem;
      min-width: 260px;
    }
    .stats dt { font-weight: 600; display: inline; }
    .stats dd { display: inline; margin: 0; }
    .stats dd::after { content: ''; display: block; }
    code { background: #eee; padding: 0.1em 0.3em; border-radius: 3px; font-size: 0.9em; }
    .legend {
      display: flex; gap: 1.2rem; flex-wrap: wrap;
      font-size: 0.8rem; margin: 0.5rem 0;
      justify-content: center;
    }
    .legend span::before {
      content: ''; display: inline-block;
      width: 10px; height: 10px; border-radius: 50%;
      margin-right: 4px; vertical-align: middle;
    }
    .legend .poles::before { background: steelblue; }
    .legend .mean::before { background: red; }
    .legend .v1::before { background: #e00; border-radius: 0; }
    .legend .v2::before { background: #0a0; border-radius: 0; }
    .legend .v3::before { background: #00c; border-radius: 0; }
  </style>
</head>
<body>
  <h1>bearing.js — Statistics &amp; Contouring</h1>
  <p>Fisher statistics, eigenvector analysis, and kernel-density contour lines.</p>

  <h2>Clustered Poles — Contour + Fisher Stats</h2>
  <div class="row">
    <div class="plot">
      <div id="cluster-plot"></div>
      <div class="legend">
        <span class="poles">Poles</span>
        <span class="mean">Mean direction</span>
      </div>
    </div>
    <div class="stats" id="cluster-stats"></div>
  </div>

  <h2>Girdle Distribution — Contour + Eigenvectors</h2>
  <div class="row">
    <div class="plot">
      <div id="girdle-plot"></div>
      <div class="legend">
        <span class="poles">Poles</span>
        <span class="v1">V1</span>
        <span class="v2">V2</span>
        <span class="v3">V3</span>
      </div>
    </div>
    <div class="stats" id="girdle-stats"></div>
  </div>

  <h2>Random Fabric</h2>
  <div class="row">
    <div class="plot">
      <div id="random-plot"></div>
    </div>
    <div class="stats" id="random-stats"></div>
  </div>

  <script type="module">
    import { Stereonet, conversions, statistics } from '../src/index.js';

    // ---- Helper: seeded pseudo-random (simple LCG) ----
    let seed = 42;
    function rand() {
      seed = (seed * 1103515245 + 12345) & 0x7fffffff;
      return seed / 0x7fffffff;
    }
    function randGauss() {
      return Math.sqrt(-2 * Math.log(rand() + 1e-10)) * Math.cos(2 * Math.PI * rand());
    }

    // ---- Helper: format vector as trend/plunge string ----
    function fmtTP(dcos) {
      const [t, p] = conversions.dcosToLine(dcos);
      return `${String(Math.round(t)).padStart(3, '0')}/${String(Math.round(p)).padStart(2, '0')}`;
    }
    const fmt = (n, d = 1) => Number(n).toFixed(d);

    // =====================================================================
    //  1.  CLUSTERED POLES
    // =====================================================================
    const clusterDcos = [];
    const clusterData = [];
    for (let i = 0; i < 60; i++) {
      let dd = 120 + randGauss() * 12;
      let dip = 45 + randGauss() * 8;
      dd = ((dd % 360) + 360) % 360;
      dip = Math.max(0, Math.min(90, dip));
      clusterData.push([dd, dip]);
      clusterDcos.push(conversions.planeToDcos(dd, dip));
    }

    const sn1 = new Stereonet({ size: 420 });
    sn1.contour(clusterDcos, {
      levels: [2, 4, 6, 8, 10],
      colors: ['#d4e6f1', '#85c1e9', '#3498db', '#2471a3', '#1a5276'],
      gridSize: 45,
      strokeWidth: 1.2,
    });
    for (const [dd, dip] of clusterData) {
      sn1.pole(dd, dip, { fill: 'steelblue', r: 2.5 });
    }

    const fisher1 = statistics.fisherStats(clusterDcos);
    const [meanT, meanP] = conversions.dcosToLine(fisher1.mean);
    sn1.line(meanT, meanP, { fill: 'red', r: 5 });
    sn1.cone(meanT, meanP, fisher1.alpha95, {
      stroke: 'red', strokeWidth: 1.2, strokeDasharray: '5,3',
    });

    document.getElementById('cluster-plot').appendChild(sn1.element());

    const pa1 = statistics.principalAxes(clusterDcos);
    document.getElementById('cluster-stats').innerHTML = `
      <h3 style="margin-top:0">Fisher Statistics</h3>
      <dl>
        <dt>n</dt> <dd>${fisher1.n}</dd>
        <dt>R</dt> <dd>${fmt(fisher1.R)}</dd>
        <dt>R\u0304</dt> <dd>${fmt(fisher1.Rbar, 3)}</dd>
        <dt>\u03ba</dt> <dd>${fmt(fisher1.kappa)}</dd>
        <dt>\u03b1\u2089\u2085</dt> <dd>${fmt(fisher1.alpha95)}\u00b0</dd>
        <dt>Mean</dt> <dd>${fmtTP(fisher1.mean)}</dd>
      </dl>
      <h3>Principal Axes</h3>
      <dl>
        <dt>S\u2081</dt> <dd>${fmt(pa1.eigenvalues[0], 3)} \u2014 ${fmtTP(pa1.eigenvectors[0])}</dd>
        <dt>S\u2082</dt> <dd>${fmt(pa1.eigenvalues[1], 3)} \u2014 ${fmtTP(pa1.eigenvectors[1])}</dd>
        <dt>S\u2083</dt> <dd>${fmt(pa1.eigenvalues[2], 3)} \u2014 ${fmtTP(pa1.eigenvectors[2])}</dd>
      </dl>
      <dl>
        <dt>Woodcock K</dt> <dd>${fmt(pa1.K, 2)} (cluster)</dd>
        <dt>Woodcock C</dt> <dd>${fmt(pa1.C, 2)}</dd>
      </dl>`;

    // =====================================================================
    //  2.  GIRDLE
    // =====================================================================
    const girdleDcos = [];
    const girdleData = [];
    for (let i = 0; i < 50; i++) {
      const strike = 45 + randGauss() * 8;
      const gDip = 10 + rand() * 70;
      const gdd = ((strike + 90) % 360 + 360) % 360;
      girdleData.push([gdd, gDip]);
      girdleDcos.push(conversions.planeToDcos(gdd, gDip));
    }

    const sn2 = new Stereonet({ size: 420 });
    sn2.contour(girdleDcos, {
      levels: [2, 4, 6],
      colors: ['#d5f5e3', '#58d68d', '#1e8449'],
      gridSize: 45,
      strokeWidth: 1.2,
    });
    for (const [dd, dip] of girdleData) {
      sn2.pole(dd, dip, { fill: 'steelblue', r: 2.5 });
    }

    const pa2 = statistics.principalAxes(girdleDcos);
    const eigColors = ['#e00', '#0a0', '#00c'];
    for (let i = 0; i < 3; i++) {
      const [et, ep] = conversions.dcosToLine(pa2.eigenvectors[i]);
      sn2.line(et, ep, { fill: eigColors[i], r: 5 });
    }
    // Best-fit great circle (plane whose pole is V3)
    const [gcDD, gcDip] = conversions.dcosToPlane(pa2.eigenvectors[2]);
    sn2.plane(gcDD, gcDip, { stroke: '#00c', strokeWidth: 1.5, strokeDasharray: '6,3' });

    document.getElementById('girdle-plot').appendChild(sn2.element());

    const fisher2 = statistics.fisherStats(girdleDcos);
    document.getElementById('girdle-stats').innerHTML = `
      <h3 style="margin-top:0">Fisher Statistics</h3>
      <dl>
        <dt>n</dt> <dd>${fisher2.n}</dd>
        <dt>\u03ba</dt> <dd>${fmt(fisher2.kappa)}</dd>
        <dt>\u03b1\u2089\u2085</dt> <dd>${fmt(fisher2.alpha95)}\u00b0</dd>
        <dt>Mean</dt> <dd>${fmtTP(fisher2.mean)}</dd>
      </dl>
      <h3>Principal Axes</h3>
      <dl>
        <dt style="color:#e00">S\u2081</dt> <dd>${fmt(pa2.eigenvalues[0], 3)} \u2014 ${fmtTP(pa2.eigenvectors[0])}</dd>
        <dt style="color:#0a0">S\u2082</dt> <dd>${fmt(pa2.eigenvalues[1], 3)} \u2014 ${fmtTP(pa2.eigenvectors[1])}</dd>
        <dt style="color:#00c">S\u2083</dt> <dd>${fmt(pa2.eigenvalues[2], 3)} \u2014 ${fmtTP(pa2.eigenvectors[2])}</dd>
      </dl>
      <dl>
        <dt>Woodcock K</dt> <dd>${fmt(pa2.K, 2)} (girdle)</dd>
        <dt>Woodcock C</dt> <dd>${fmt(pa2.C, 2)}</dd>
      </dl>`;

    // =====================================================================
    //  3.  RANDOM (weakly preferred orientation)
    // =====================================================================
    const randomDcos = [];
    const randomData = [];
    for (let i = 0; i < 80; i++) {
      const rdd = rand() * 360;
      const rdip = rand() * 90;
      randomData.push([rdd, rdip]);
      randomDcos.push(conversions.planeToDcos(rdd, rdip));
    }

    const sn3 = new Stereonet({ size: 420 });
    sn3.contour(randomDcos, {
      levels: [2, 3, 4],
      colors: ['#fdebd0', '#f0b27a', '#d35400'],
      gridSize: 45,
      strokeWidth: 1.2,
    });
    for (const [dd, dip] of randomData) {
      sn3.pole(dd, dip, { fill: '#555', r: 2 });
    }

    document.getElementById('random-plot').appendChild(sn3.element());

    const fisher3 = statistics.fisherStats(randomDcos);
    const pa3 = statistics.principalAxes(randomDcos);
    document.getElementById('random-stats').innerHTML = `
      <h3 style="margin-top:0">Fisher Statistics</h3>
      <dl>
        <dt>n</dt> <dd>${fisher3.n}</dd>
        <dt>\u03ba</dt> <dd>${fmt(fisher3.kappa)}</dd>
        <dt>\u03b1\u2089\u2085</dt> <dd>${fmt(fisher3.alpha95)}\u00b0</dd>
      </dl>
      <h3>Principal Axes</h3>
      <dl>
        <dt>S\u2081</dt> <dd>${fmt(pa3.eigenvalues[0], 3)} \u2014 ${fmtTP(pa3.eigenvectors[0])}</dd>
        <dt>S\u2082</dt> <dd>${fmt(pa3.eigenvalues[1], 3)} \u2014 ${fmtTP(pa3.eigenvectors[1])}</dd>
        <dt>S\u2083</dt> <dd>${fmt(pa3.eigenvalues[2], 3)} \u2014 ${fmtTP(pa3.eigenvectors[2])}</dd>
      </dl>
      <dl>
        <dt>Woodcock K</dt> <dd>${fmt(pa3.K, 2)}</dd>
        <dt>Woodcock C</dt> <dd>${fmt(pa3.C, 2)} (weak fabric)</dd>
      </dl>`;
  </script>
</body>
</html>
